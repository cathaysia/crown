use super::*;

struct AnubisTest {
    _keylen: usize,
    pt: [u8; 16],
    ct: [u8; 16],
    key: &'static [u8],
}

const ANUBIS_TESTS: &[AnubisTest] = &[
    // 128 bit keys
    AnubisTest {
        _keylen: 16,
        pt: [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ],
        ct: [
            0xB8, 0x35, 0xBD, 0xC3, 0x34, 0x82, 0x9D, 0x83, 0x71, 0xBF, 0xA3, 0x71, 0xE4, 0xB3,
            0xC4, 0xFD,
        ],
        key: &[
            0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ],
    },
    AnubisTest {
        _keylen: 16,
        pt: [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ],
        ct: [
            0xE6, 0x14, 0x1E, 0xAF, 0xEB, 0xE0, 0x59, 0x3C, 0x48, 0xE1, 0xCD, 0xF2, 0x1B, 0xBA,
            0xA1, 0x89,
        ],
        key: &[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x01,
        ],
    },
    // 160-bit keys
    AnubisTest {
        _keylen: 20,
        pt: [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ],
        ct: [
            0x97, 0x59, 0x79, 0x4B, 0x5C, 0xA0, 0x70, 0x73, 0x24, 0xEF, 0xB3, 0x58, 0x67, 0xCA,
            0xD4, 0xB3,
        ],
        key: &[
            0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ],
    },
    AnubisTest {
        _keylen: 20,
        pt: [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ],
        ct: [
            0xB8, 0x0D, 0xFB, 0x9B, 0xE4, 0xA1, 0x58, 0x87, 0xB3, 0x76, 0xD5, 0x02, 0x18, 0x95,
            0xC1, 0x2E,
        ],
        key: &[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        ],
    },
    // 192-bit keys
    AnubisTest {
        _keylen: 24,
        pt: [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ],
        ct: [
            0x7D, 0x62, 0x3B, 0x52, 0xC7, 0x4C, 0x64, 0xD8, 0xEB, 0xC7, 0x2D, 0x57, 0x97, 0x85,
            0x43, 0x8F,
        ],
        key: &[
            0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ],
    },
    AnubisTest {
        _keylen: 24,
        pt: [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ],
        ct: [
            0xB1, 0x0A, 0x59, 0xDD, 0x5D, 0x5D, 0x8D, 0x67, 0xEC, 0xEE, 0x4A, 0xC4, 0xBE, 0x4F,
            0xA8, 0x4F,
        ],
        key: &[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        ],
    },
    // 224-bit keys
    AnubisTest {
        _keylen: 28,
        pt: [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ],
        ct: [
            0x68, 0x9E, 0x05, 0x94, 0x6A, 0x94, 0x43, 0x8F, 0xE7, 0x8E, 0x37, 0x3D, 0x24, 0x97,
            0x92, 0xF5,
        ],
        key: &[
            0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ],
    },
    AnubisTest {
        _keylen: 28,
        pt: [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ],
        ct: [
            0xDD, 0xB7, 0xB0, 0xB4, 0xE9, 0xB4, 0x9B, 0x9C, 0x38, 0x20, 0x25, 0x0B, 0x47, 0xC2,
            0x1F, 0x89,
        ],
        key: &[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        ],
    },
    // 256-bit keys
    AnubisTest {
        _keylen: 32,
        pt: [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ],
        ct: [
            0x96, 0x00, 0xF0, 0x76, 0x91, 0x69, 0x29, 0x87, 0xF5, 0xE5, 0x97, 0xDB, 0xDB, 0xAF,
            0x1B, 0x0A,
        ],
        key: &[
            0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ],
    },
    AnubisTest {
        _keylen: 32,
        pt: [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ],
        ct: [
            0x69, 0x9C, 0xAF, 0xDD, 0x94, 0xC7, 0xBC, 0x60, 0x44, 0xFE, 0x02, 0x05, 0x8A, 0x6E,
            0xEF, 0xBD,
        ],
        key: &[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x01,
        ],
    },
    // 288-bit keys
    AnubisTest {
        _keylen: 36,
        pt: [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ],
        ct: [
            0x0F, 0xC7, 0xA2, 0xC0, 0x11, 0x17, 0xAC, 0x43, 0x52, 0x5E, 0xDF, 0x6C, 0xF3, 0x96,
            0x33, 0x6C,
        ],
        key: &[
            0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ],
    },
    AnubisTest {
        _keylen: 36,
        pt: [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ],
        ct: [
            0xAD, 0x08, 0x4F, 0xED, 0x55, 0xA6, 0x94, 0x3E, 0x7E, 0x5E, 0xED, 0x05, 0xA1, 0x9D,
            0x41, 0xB4,
        ],
        key: &[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        ],
    },
    // 320-bit keys
    AnubisTest {
        _keylen: 40,
        pt: [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ],
        ct: [
            0xFE, 0xE2, 0x0E, 0x2A, 0x9D, 0xC5, 0x83, 0xBA, 0xA3, 0xA6, 0xD6, 0xA6, 0xF2, 0xE8,
            0x06, 0xA5,
        ],
        key: &[
            0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ],
    },
    AnubisTest {
        _keylen: 40,
        pt: [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ],
        ct: [
            0x86, 0x3D, 0xCC, 0x4A, 0x60, 0x34, 0x9C, 0x28, 0xA7, 0xDA, 0xA4, 0x3B, 0x0A, 0xD7,
            0xFD, 0xC7,
        ],
        key: &[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        ],
    },
];

fn compare_testvector(actual: &[u8], expected: &[u8], test_name: &str, test_index: usize) -> bool {
    if actual != expected {
        panic!(
            "{} test {}: got {:02x?}, expected {:02x?}",
            test_name, test_index, actual, expected
        );
    }
    false
}

#[test]
fn anubis_test() {
    let mut buf = [[0u8; 16]; 2];

    for (x, test) in ANUBIS_TESTS.iter().enumerate() {
        let skey = Anubis::new(test.key).expect("Failed to create Anubis cipher");

        // Test encryption
        buf[0] = test.pt;
        skey.encrypt_block(&mut buf[0]);

        // Test decryption
        skey.decrypt_block(&mut buf[0]);
        buf[1] = buf[0];

        // Verify encryption result
        buf[0] = test.pt;
        skey.encrypt_block(&mut buf[0]);
        compare_testvector(&buf[0], &test.ct, "Anubis Encrypt", x);

        // Verify decryption result
        compare_testvector(&buf[1], &test.pt, "Anubis Decrypt", x);

        // Performance test: 1000 encryptions followed by 1000 decryptions
        for _ in 0..1000 {
            skey.encrypt_block(&mut buf[0]);
        }
        for _ in 0..1000 {
            skey.decrypt_block(&mut buf[0]);
        }
        compare_testvector(&buf[0], &test.ct, "Anubis 1000", 1000);
    }
}

#[test]
fn test_anubis_block_size() {
    let key = [0u8; 16];
    let cipher = Anubis::new(&key).unwrap();
    assert_eq!(cipher.block_size(), 16);
}

#[test]
fn test_anubis_invalid_key_sizes() {
    for &invalid_size in &[0, 8, 15, 17, 41, 64] {
        let key = vec![0u8; invalid_size];
        match Anubis::new(&key) {
            Ok(_) => panic!("Expected error for key size {}", invalid_size),
            Err(crate::error::CryptoError::InvalidKeySize {
                expected: _,
                actual: size,
            }) => {
                assert_eq!(size, invalid_size);
            }
            _ => unreachable!(),
        }
    }
}

#[test]
fn test_anubis_valid_key_sizes() {
    for &valid_size in &[16, 20, 24, 28, 32, 36, 40] {
        let key = vec![0u8; valid_size];
        match Anubis::new(&key) {
            Ok(cipher) => {
                assert_eq!(cipher.block_size(), 16);
                assert_eq!(cipher.key_bits, (valid_size * 8) as i32);
            }
            Err(e) => panic!("Unexpected error for valid key size {}: {}", valid_size, e),
        }
    }
}
